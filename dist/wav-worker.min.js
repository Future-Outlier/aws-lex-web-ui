let f = 0, u = [];
const s = {
  sampleRate: 44e3,
  numChannels: 1,
  useDownsample: !0,
  // controls if the encoder will trim silent samples at begining and end of buffer
  useTrim: !0,
  // trim samples below this value at the beginnig and end of the buffer
  // lower the value trim less silence (larger file size)
  // reasonable values seem to be between 0.005 and 0.0005
  quietTrimThreshold: 8e-4,
  // how many samples to add back to the buffer before/after the quiet threshold
  // higher values result in less silence trimming (larger file size)
  // reasonable values seem to be between 3500 and 5000
  quietTrimSlackBack: 4e3
};
self.onmessage = (e) => {
  switch (e.data.command) {
    case "init":
      k(e.data.config);
      break;
    case "record":
      C(e.data.buffer);
      break;
    case "exportWav":
      U(e.data.type);
      break;
    case "getBuffer":
      T();
      break;
    case "clear":
      R();
      break;
    case "close":
      self.close();
      break;
  }
};
function k(e) {
  Object.assign(s, e), b();
}
function C(e) {
  for (let t = 0; t < s.numChannels; t++)
    u[t].push(e[t]);
  f += e[0].length;
}
function U(e) {
  const t = [];
  for (let r = 0; r < s.numChannels; r++)
    t.push(B(u[r], f));
  let n;
  s.numChannels, n = t[0];
  const o = y(n, 16e3), a = x(o), l = new Blob([a], { type: e });
  self.postMessage({
    command: "exportWAV",
    data: l
  });
}
function T() {
  const e = [];
  for (let t = 0; t < s.numChannels; t++)
    e.push(B(u[t], f));
  self.postMessage({ command: "getBuffer", data: e });
}
function R() {
  f = 0, u = [], b();
}
function b() {
  for (let e = 0; e < s.numChannels; e++)
    u[e] = [];
}
function B(e, t) {
  const n = new Float32Array(t);
  let o = 0;
  for (let a = 0; a < e.length; a++)
    n.set(e[a], o), o += e[a].length;
  return n;
}
function S(e, t, n) {
  for (let o = 0, a = t; o < n.length; o++, a += 2) {
    const l = Math.max(-1, Math.min(1, n[o]));
    e.setInt16(a, l < 0 ? l * 32768 : l * 32767, !0);
  }
}
function M(e, t) {
  e.setUint32(0, 1380533830, !1), e.setUint32(4, 36 + t, !0), e.setUint32(8, 1463899717, !1), e.setUint32(12, 1718449184, !1), e.setUint32(16, 16, !0), e.setUint16(20, 1, !0), e.setUint16(22, 1, !0), e.setUint32(24, 16e3, !0), e.setUint32(28, 16e3 * 2 * 1, !0), e.setUint16(32, 2 * 1, !0), e.setUint16(34, 16, !0), e.setUint32(36, 1684108385, !1);
}
function x(e) {
  const t = new ArrayBuffer(44 + e.length * 2), n = new DataView(t);
  return M(n, e.length), S(n, 44, e), n;
}
function y(e, t) {
  if (t === s.sampleRate)
    return e;
  const n = e.length, o = s.sampleRate / t, a = Math.round(n / o), l = new Float32Array(a);
  let r = 0, m = 0, i = 0, d = n;
  for (; r < l.length; ) {
    const p = Math.round((r + 1) * o);
    let h = 0, g = 0;
    for (let c = m; c < p && c < n; c++)
      h += e[c], g++;
    h > s.quietTrimThreshold && (i === 0 && (i = r), d = r), l[r] = h / g, r++, m = p;
  }
  return s.useTrim ? (
    // slice based on quiet threshold and put slack back into the buffer
    l.slice(
      Math.max(0, i - s.quietTrimSlackBack),
      Math.min(a, d + s.quietTrimSlackBack)
    )
  ) : l;
}
